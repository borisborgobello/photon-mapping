<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Photon-Mapping: Sphere Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Sphere Class Reference</h1><!-- doxytag: class="Sphere" --><!-- doxytag: inherits="Volume" -->
<p>Derived from <a class="el" href="class_volume.html" title="Derived from Shape, representing a volume.">Volume</a>, representing a sphere in space.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sphere_8hpp_source.html">sphere.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sphere:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_sphere.png" usemap="#Sphere_map" alt=""/>
  <map id="Sphere_map" name="Sphere_map">
<area href="class_volume.html" alt="Volume" shape="rect" coords="0,56,54,80"/>
<area href="class_shape.html" alt="Shape" shape="rect" coords="0,0,54,24"/>
</map>
 </div>
</div>

<p><a href="class_sphere-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sphere.html#a289b9fca28b0bddf6bbe530f3f9b34cb">Sphere</a> (double absorp, double reflect, double refract, double index, <a class="el" href="class_texture.html">Texture</a> *tex, <a class="el" href="geometry_8hpp.html#acbb5e81e5c7df7d7289ef6c117e0e6d1">Point3D</a> center, double radius)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a289b9fca28b0bddf6bbe530f3f9b34cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sphere.html#ad772f0cac26e74fc64b5f9f10dd44e17">is_intersected_by</a> (const <a class="el" href="class_launchable.html">Launchable</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether this sphere is intersected by a given launchable.  <a href="#ad772f0cac26e74fc64b5f9f10dd44e17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="geometry_8hpp.html#a879758e1dddb901dbd5c6d1abc7b2202">Couple3D</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sphere.html#a361fc4fc2e360c785e17fa029e66f168">get_nearest_intersection_with_normal</a> (const <a class="el" href="class_launchable.html">Launchable</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the nearest intersection (point/normal) of the given launchable with this sphere.  <a href="#a361fc4fc2e360c785e17fa029e66f168"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sphere.html#a51e8767ee51e6fd41da47577e5bf2c52">redirect_photon</a> (const <a class="el" href="geometry_8hpp.html#a879758e1dddb901dbd5c6d1abc7b2202">Couple3D</a> &amp;, <a class="el" href="class_photon.html">Photon</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Redirects (or not) a given photon depending on the probilities of this sphere.  <a href="#a51e8767ee51e6fd41da47577e5bf2c52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_ray.html">Ray</a>, <a class="el" href="class_ray.html">Ray</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sphere.html#a24393587dbed3c0380de4b95592c1ead">divide_ray</a> (const <a class="el" href="geometry_8hpp.html#a879758e1dddb901dbd5c6d1abc7b2202">Couple3D</a> &amp;, const <a class="el" href="class_ray.html">Ray</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the division (reflected/refracted) of an incoming ray at the couple position.  <a href="#a24393587dbed3c0380de4b95592c1ead"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="geometry_8hpp.html#a879758e1dddb901dbd5c6d1abc7b2202">Couple3D</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sphere.html#aeaf00977e931d008d3ff49fdebe6ec0e">get_random_point_and_normal</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random surface point and a random normal of the sphere.  <a href="#aeaf00977e931d008d3ff49fdebe6ec0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_color.html">Color</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sphere.html#ab064574155c4bd958306b0fc783e9f80">get_color_at</a> (const <a class="el" href="geometry_8hpp.html#acbb5e81e5c7df7d7289ef6c117e0e6d1">Point3D</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the color at this point of the sphere.  <a href="#ab064574155c4bd958306b0fc783e9f80"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Derived from <a class="el" href="class_volume.html" title="Derived from Shape, representing a volume.">Volume</a>, representing a sphere in space. </p>
<p>The sphere can reflect and refract Launchables. It can be intersected by a <a class="el" href="class_launchable.html" title="Base class for Photon and Ray.">Launchable</a> from inside or outside </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a289b9fca28b0bddf6bbe530f3f9b34cb"></a><!-- doxytag: member="Sphere::Sphere" ref="a289b9fca28b0bddf6bbe530f3f9b34cb" args="(double absorp, double reflect, double refract, double index, Texture *tex, Point3D center, double radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sphere::Sphere </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>absorp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>reflect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>refract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_texture.html">Texture</a> *&nbsp;</td>
          <td class="paramname"> <em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="geometry_8hpp.html#acbb5e81e5c7df7d7289ef6c117e0e6d1">Point3D</a>&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>radius</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Constructor of class <a class="el" href="class_sphere.html" title="Derived from Volume, representing a sphere in space.">Sphere</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>absorp</em>&nbsp;</td><td>: absorption probability </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reflect</em>&nbsp;</td><td>: reflection probability </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refract</em>&nbsp;</td><td>: refraction probability </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>: index (material) of this <a class="el" href="class_sphere.html" title="Derived from Volume, representing a sphere in space.">Sphere</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tex</em>&nbsp;</td><td>: pointer to the texture of this <a class="el" href="class_sphere.html" title="Derived from Volume, representing a sphere in space.">Sphere</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>: center of the <a class="el" href="class_sphere.html" title="Derived from Volume, representing a sphere in space.">Sphere</a> in space </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>: radius of the <a class="el" href="class_sphere.html" title="Derived from Volume, representing a sphere in space.">Sphere</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a24393587dbed3c0380de4b95592c1ead"></a><!-- doxytag: member="Sphere::divide_ray" ref="a24393587dbed3c0380de4b95592c1ead" args="(const Couple3D &amp;, const Ray &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_ray.html">Ray</a>, <a class="el" href="class_ray.html">Ray</a> &gt; Sphere::divide_ray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="geometry_8hpp.html#a879758e1dddb901dbd5c6d1abc7b2202">Couple3D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>couple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ray.html">Ray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ray</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the division (reflected/refracted) of an incoming ray at the couple position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ray</em>&nbsp;</td><td>: the incoming ray to divide </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>couple</em>&nbsp;</td><td>: first parameter contains the intersection point, second contains the normal at this intersection</td></tr>
  </table>
  </dd>
</dl>
<p>This function divides a ray into a reflected and refracted ray only if the new ray can exist (probabilities not null). In case of a total reflection, the refracted ray has a null direction </p>

<p>Implements <a class="el" href="class_shape.html#abaed76731aefbf8e3fbfbc238b8425cf">Shape</a>.</p>

</div>
</div>
<a class="anchor" id="ab064574155c4bd958306b0fc783e9f80"></a><!-- doxytag: member="Sphere::get_color_at" ref="ab064574155c4bd958306b0fc783e9f80" args="(const Point3D &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_color.html">Color</a> Sphere::get_color_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="geometry_8hpp.html#acbb5e81e5c7df7d7289ef6c117e0e6d1">Point3D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inters_point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the color at this point of the sphere. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inters_point</em>&nbsp;</td><td>: an intersection point where we seek the color</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines the color at the given point of the surface It is related to the get_color(double, double) of the <a class="el" href="class_texture.html" title="Base class representing any texture.">Texture</a> where the two doubles represent coordinates for the texture map. </p>

<p>Implements <a class="el" href="class_shape.html#a6fe6c81daa56759cc9f2b501fd3953d3">Shape</a>.</p>

</div>
</div>
<a class="anchor" id="a361fc4fc2e360c785e17fa029e66f168"></a><!-- doxytag: member="Sphere::get_nearest_intersection_with_normal" ref="a361fc4fc2e360c785e17fa029e66f168" args="(const Launchable &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="geometry_8hpp.html#a879758e1dddb901dbd5c6d1abc7b2202">Couple3D</a> Sphere::get_nearest_intersection_with_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_launchable.html">Launchable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the nearest intersection (point/normal) of the given launchable with this sphere. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>: the incoming launchable to find intersection with</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a couple containing the nearest intersection point (first param) with this <a class="el" href="class_sphere.html" title="Derived from Volume, representing a sphere in space.">Sphere</a> and the normal at intersection point (second param) </p>

<p>Implements <a class="el" href="class_shape.html#a044bde3a328252aeaf02b3a9f945db68">Shape</a>.</p>

</div>
</div>
<a class="anchor" id="aeaf00977e931d008d3ff49fdebe6ec0e"></a><!-- doxytag: member="Sphere::get_random_point_and_normal" ref="aeaf00977e931d008d3ff49fdebe6ec0e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="geometry_8hpp.html#a879758e1dddb901dbd5c6d1abc7b2202">Couple3D</a> Sphere::get_random_point_and_normal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a random surface point and a random normal of the sphere. </p>
<p>Returns a couple containing as first parameter a random point of the surface of the sphere from where to emit, and a corresponding normal as second parameter </p>

<p>Implements <a class="el" href="class_volume.html#a0800b634d4a8ac2e2d1c6b14c9ae1b04">Volume</a>.</p>

</div>
</div>
<a class="anchor" id="ad772f0cac26e74fc64b5f9f10dd44e17"></a><!-- doxytag: member="Sphere::is_intersected_by" ref="ad772f0cac26e74fc64b5f9f10dd44e17" args="(const Launchable &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sphere::is_intersected_by </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_launchable.html">Launchable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this sphere is intersected by a given launchable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>: the incoming launchable to test collision with</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns whether the launchable direction will lead to a collision with this sphere </p>

<p>Implements <a class="el" href="class_shape.html#ab8bd8a89f19be0e41de5497bf6d34e82">Shape</a>.</p>

</div>
</div>
<a class="anchor" id="a51e8767ee51e6fd41da47577e5bf2c52"></a><!-- doxytag: member="Sphere::redirect_photon" ref="a51e8767ee51e6fd41da47577e5bf2c52" args="(const Couple3D &amp;, Photon &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sphere::redirect_photon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="geometry_8hpp.html#a879758e1dddb901dbd5c6d1abc7b2202">Couple3D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>couple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_photon.html">Photon</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Redirects (or not) a given photon depending on the probilities of this sphere. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&nbsp;</td><td>: the incoming photon to redirect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>couple</em>&nbsp;</td><td>: first parameter contains the intersection point, second contains the normal at this intersection</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if a photon will be aborbed, reflected or refracted depending on the corresponding probabilities specified for this sphere It returns TRUE is the photon was redirected, and FALSE if the photon was absorbed. </p>

<p>Implements <a class="el" href="class_shape.html#af05d07747aa15cc343a648d262b004f5">Shape</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/projet/Cpp/Photon-Mapping/SVN/src/shapes/<a class="el" href="sphere_8hpp_source.html">sphere.hpp</a></li>
<li>C:/projet/Cpp/Photon-Mapping/SVN/src/shapes/<a class="el" href="sphere_8cpp.html">sphere.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon May 10 16:01:06 2010 for Photon-Mapping by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
